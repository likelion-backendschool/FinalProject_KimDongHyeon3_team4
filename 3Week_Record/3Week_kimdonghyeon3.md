# 필수과제
- [x] 관리자회원
- [x] 관리자페이지
- [x] 정산데이터 생성
- [x] 건별정산처리
- [x] 전체정산처리

# 추가과제
- [ ] 정산데이터를 배치로 생성
- [x] 출금신청기능(사용자기능)
- [x] 출금처리기능(관리자기능)

# 접근방법

3주차 파이널 프로젝트의 경우 관리자 페이지에 대한 내용이 주를 이루었다. 해당 주차에서
주의 깊게 봐야할 점은 상품(도서)를 구매한 후 어떻게 판매자에게 수익금을 분배할지에 관한 문제였다.

해당 문제를 해결하기 위해서 어떻한 방식으로 과제들을 진행해야 할지 가닥을 잡았다.

1. 관지자 회원 생성
2. 관리자 페이지 생성
3. 정산데이터 생성
4. 건별정산처리
5. 정체정산처리
6. 정산데이터 배치 생성
7. 출금 신청 기능 (사용자)
8. 출금 신청 내역 (사용자)
9. 출금 처리 기능 (관리자)

총 9가지의 단계로 구성하여 과제를 진행하였다.

---
## - 관리자 회원 생성

관리자 회원 생성은 1주차 미션때 이미 구현을 해논 상태였다. 1주차 과제의 제한 요건 중 authlevel을 통해
3이면 일반회원, 7이면 관리자 회원으로 인식하도록 만들어야 했다. 

따라서 Security를 통해서 authlevel이 7이면 ADMIN이라는 권한을 부여하여 이를 해결하였다.
(관리자 ID : admin / PW : 1111)
---
## - 관리자 페이지 생성

관리자 페이지는 앞선 관리자 회원의 연장선이다. 아무나 들어갈 수 있도록 하는 것이 아니라 앞서 Secruity에 저장한
ADMIN이라는 권한이 있을 경우에만 허용을 해준다는 점을 고려해서 구현하면 되었다.

```
@PreAuthorize("hasAuthority('ADMIN')")
```
를 활용해서 해당 컨트롤러에 ADMIN 계정만 들어올 수 있도록 구현하였다.

접근 방식을 세울 것도 없이 Controller를 통해
View를 반환해 주기만 하면된다.


---
## - 정산데이터 생성

정산 데이터 생성은 이전에 진행했던 음반판매 부분을 참고하였다. 주문이 완료된 내역 즉, 결제가 된 상품들을
나열하여 정산 데이터로 생성을 하면된다. 조금 고려해야 되는 부분은, 생성된 날짜데이터를 다루는 부분이다.


날짜를 다루는 부분에서, 일정한 형식을 통일하여 jpa를 통해 값을 가져와야 하기 때문이다.
```aidl
//2022-11 이라는 데이터를 변환하는 과정

int monthEndDay = Util.date.getEndDayOf(yearMonth);

String fromDateStr = yearMonth + "-01 00:00:00.000000";
String toDateStr = yearMonth + "-%02d 23:59:59.999999".formatted(monthEndDay);
LocalDateTime fromDate = Util.date.parse(fromDateStr);
LocalDateTime toDate = Util.date.parse(toDateStr);
```
Util의 클래스의 메서드는, Directory를 참고하면 된다.

여기서 중요한 점은 만약 11월의 데이터를 가져왔다면, 11월의 00시부터 11월30일 23.99시까지의 데이터를
필요로 한다는 점이다. 이를 위해서 "-01 00:00:00.000000"이러한 값을 더해준다.

추가적으로 음반판매부분을 참고하면서 정산의 프로세스에 대해서 이해해보면, 
정산 데이터를 만드는데 많은 도움이 된다.

 1. 주문된 데이터를 가져온다.
2. 주문된 데이터에 담겨 있는 상품(도서)를 가져온다.
3. 가져온 상품(도서)데이터를 정산 상품(도서)테이터로변환해 넣어준다.
4. 변환된 데이터를 저장한다.
5. 변환된 데이터를 사용자의 요청에 맞는 일자의 데이털르 반환한다.

이렇게 5가지의 단계를 거친다고 생각하면 된다. 음반판매를 참고하다보니
형식은 이렇긴한데,, 좀만 더 고려해 본다면

첫 List페이지의 경우 모든 정산 데이터 들을 보여주고,
필터, 검색 이러한 기능을 통해서 정산 데이터들을 선택적으로
정산할 수 있도록 보여주는 것이 좋아보인다.
(체크 박스를 통해 정산안된 데이터만 보기 등)

 이러한 기능은 리팩토링 시간을 통해 고도화 시켜보자!

---
# - 건별 정산처리 & 전체 정산처리

사실 해당 기능들은 분리해서 계획했지만, 개발을 하다보니 그리 나누어 생각해 볼 것이 아니였다.
건별 정산처리를 구현했다면 전체 정산처리는, 해당 부분을 반복만 해주면 된다.

건별 정산처리에서 중요한 점은 정산 처리가 가능한가를 고려해야한다.

 - 환불이 되었는가
 - 해당 주문이 존재하는가
 - 해당 주문이 결제되었는가
 - 해당주문이 이미 정산 처리가 되었는가

크게 4가지에 대한 검증을 통해서 정산을 할 수 있도록 제작한다. 이러한 검증 과정을 지나간 후에는
정산이 된 데이터를 다시 넣어주어야 한다. 이때 고려해야 하는 점은 아래와 같다.

 - 정산된 금액은 판마자 예치금으로 넣어주어야한다.
 - 정산된 금액중 관리자가 가지는 수수료를 기억해야한다.
 - 정산된 데이터는 다시 정산되면 안된다.

이러한 제약사항을 정리하여 건별 정산처리 기능을 구현하였다.

 + 전체 정산처리의 경우 JS처리 부분을 신경써야 했다. 해당 부분은 사실 심도 있게 다루지 않고
강사님의 코드를 참고했다. (전체 선택, 부분 선택 후 Controller에 값넘기기)

---
## - 출금 신청 기능 (사용자)
출금 신청 기능은 요구사항 명세서에 나와있듯이, 은행/계좌번호/출금할 금액
3가지의 데이터를 넘겨주면 된다. 사실 Form의 경우 크게 어렵지 않게 작성할 수 있다.
이전에 작성했던 OrderForm을 참고하면 예치금의 Max 즉, 자신의 에치금을 넘어가는 금액을
출금할 수 없도록 프론트단에서 검증을 해야한다. 따라서 이러한 제약사항들을 고려하여
아래의 개발 프로세스를 생각했다.

 - 사용자의 입력을 받는다.
 - 출금할 수 있는 예치금의 한도인지 검증한다.
 - 해당 데이터를 서버에 보낸다.
 - 보낸 데이터를 기반으로 출금 Entity를 만들어 저장한다.

총 4가지의 프로세스를 고려하여 진행하게 되었다.

---
## - 출금 신청 내역 (사용자)
해당 부분에 대한 기능은 사실 큰 의미는 없지만, 자신이 신청한 출금 내역을 사용자는 살펴볼 수 있어야
한다고 생각하여 해당 기능을 추가하였다. 구현을 DB에 있는 출금 Entity를 가져와
사용자가 보기 편하도록 출력만 하면 되기 때문에 크게 어렵지 않게 구현할 수 있다.

---
## - 출금 처리 기능 (관리자)
해당 기능의 경우 어떻게 처리를 해야할까 고민이 많았다. 해당 기능을 완벽하게 구현하기 위해서는
출금 처리가 된다면, 해당 금액을 정확히 사용자의 계좌로 넣어주어야한다. 크게 생각해본다면,
2가지 방법이 있다.

 - 수동적으로 하나하나 자신이 직접 이체를 한후 출금 처리 버튼을 누른다.
 - 계좌를 연동해 자동으로 이체가 되게한다.

사실 두번째 방식이 좀 더 효율적이 방법이지만, 해당 기능을 구현하기 위해서는 많은 어려움이 있어보인다.
시간 관계상 해당 내용을 구현하지 못할 것을 예상했고 이에 따라서 리팩토링에 추가한다.

이러한 계획으로 수동적으로 하나하나 자신이 직접 이체를 한 후 출금 처리 번튼을 누를 수 있도록
출금 처리를 할 수 있도록, 출금 Entity를 모두 출력하 해당 내용을 출금 처리를 한다면
해당 내용은 더이상 출금을 완료한 생태로 변경되고, 이를 파악할 수 있는 페이지를 만드는 방식으로
해당 기능을 구현하였다.

 * 참고할 이체 API : 
   https://www.openbanking.or.kr/apt/content/openapi

---
# 특이사항

### [정산 배치]

추가 기능중 정산으로 일정 기간에 알아서 정산이 되도록 하는 기능을 구현하지 못하였다.
차후 리팩토링시간을 가져가면서 해당 기능을 추가할 예정이다.


### [오픈뱅킹 API]

출금 처리 기능(관리자)를 제작하면서 자동으로 이체가 된다면,
더욱 효율적인 기능이 될거라 생각하여, 참고 자료를 남겨두고
리팩토링 시간을 통해 해당 기능을 추가할 예정이다.

### [정산 데이터 생성 ERROR]

음원판매에서 정산 데이터를 생성함에 있어서 오류의 부분을 해결할 수 있었다.
```aidl
@Transactional
public void makeAmdRebateOrderItem(RebateOrderItem item) {
    RebateOrderItem oldRebateOrderItem = rebateOrderItemRepository.findByOrderItemId(item.getOrderItem().getId()).orElse(null);

    if (oldRebateOrderItem != null) {
        revenueService.deleteByRebateOrderItem(oldRebateOrderItem);
        rebateOrderItemRepository.delete(oldRebateOrderItem);
    }

    rebateOrderItemRepository.save(item);
}
```
해당 코드에서 생성된 데이터를 정산처리를 한 후 또다시 같은 달의 데이털르 생성하게 되면, 해당 코드 부분때문에
이전에 정산되었던 데이터가 삭제되고 다시 저장되기 떄문에
중복 정산의 가능성이 생기게 되었다. 이러한 부분을 아래와 같이 수정하였따.

```aidl
    @Transactional
    public void makeAmdRebateOrderItem(RebateOrderItem item) {
        RebateOrderItem oldRebateOrderItem = rebateOrderItemRepository.findByOrderItemId(item.getOrderItem().getId()).orElse(null);
        if (oldRebateOrderItem == null) {
            rebateOrderItemRepository.save(item);
        }
    }
```
정산 프로세스를 이해해보면, 정산 데이터를 생성한후 정산을 진행하게 된다. 
그렇다면, 정산 데이터를 생성할 때, 기존에 먼저 개별적으로
정산을 완료한 경우라면, oldRebateOrderItem 즉, 정산 아이템이
이미 만들어져 있다. 그럴 경우, 굳이 삭제후 다시 만들 필요가 없다.

또한 정산 데이터의 경우 주문된 데이터를 기반으로 만들어 지기 때문에
환불, 취소된 주문의 데이터만 걸러서 만들면 되기 때문에
굳이 Delete를 할 필요가 없어 본인다.


